/**
 * THIS FILE IS GENERATED - DO NOT MODIFY DIRECTLY
 * Generated by @near-jsonrpc/jsonrpc-generator
 * 
 * @generated
 */
import { z } from "zod/v4";
import type { Action } from "./schemas";

export const AccessKeySchema = z.object({
    nonce: z.number(),
    permission: z.lazy(() => AccessKeyPermissionSchema)
});
export const AccessKeyCreationConfigViewSchema = z.object({
    full_access_cost: z.lazy(() => FeeSchema),
    function_call_cost: z.lazy(() => FeeSchema),
    function_call_cost_per_byte: z.lazy(() => FeeSchema)
});
export const AccessKeyInfoViewSchema = z.object({
    access_key: z.lazy(() => AccessKeyViewSchema),
    public_key: z.lazy(() => PublicKeySchema)
});
export const AccessKeyListSchema = z.object({
    keys: z.array(AccessKeyInfoViewSchema)
});
export const AccessKeyPermissionSchema = z.union([z.object({
    FunctionCall: z.lazy(() => FunctionCallPermissionSchema)
}), z.literal("FullAccess")]);
export const AccessKeyPermissionViewSchema = z.union([z.literal("FullAccess"), z.object({
    FunctionCall: z.object({
        allowance: z.union([z.string(), z.null()]).optional(),
        method_names: z.array(z.string()),
        receiver_id: z.string()
    })
})]);
export const AccessKeyViewSchema = z.object({
    nonce: z.number(),
    permission: AccessKeyPermissionViewSchema
});
export const AccountCreationConfigViewSchema = z.object({
    min_allowed_top_level_account_length: z.number(),
    registrar_account_id: z.lazy(() => AccountIdSchema)
});
export const AccountDataViewSchema = z.object({
    account_key: z.lazy(() => PublicKeySchema),
    peer_id: z.lazy(() => PublicKeySchema),
    proxies: z.array(z.lazy(() => Tier1ProxyViewSchema)),
    timestamp: z.string()
});
export const AccountIdSchema = z.string();
export const AccountIdValidityRulesVersionSchema = z.number();
export const AccountInfoSchema = z.object({
    account_id: AccountIdSchema,
    amount: z.string(),
    public_key: z.lazy(() => PublicKeySchema)
});
export const AccountViewSchema = z.object({
    amount: z.string(),
    code_hash: z.lazy(() => CryptoHashSchema),
    global_contract_account_id: z.union([AccountIdSchema, z.null()]).optional(),
    global_contract_hash: z.union([z.lazy(() => CryptoHashSchema), z.null()]).optional(),
    locked: z.string(),
    storage_paid_at: z.number(),
    storage_usage: z.number()
});
export const AccountWithPublicKeySchema = z.object({
    account_id: AccountIdSchema,
    public_key: z.lazy(() => PublicKeySchema)
});
export const ActionSchema: z.ZodType<Action> = z.union([z.object({
    CreateAccount: z.lazy(() => CreateAccountActionSchema)
}), z.object({
    DeployContract: z.lazy(() => DeployContractActionSchema)
}), z.object({
    FunctionCall: z.lazy(() => FunctionCallActionSchema)
}), z.object({
    Transfer: z.lazy(() => TransferActionSchema)
}), z.object({
    Stake: z.lazy(() => StakeActionSchema)
}), z.object({
    AddKey: z.lazy(() => AddKeyActionSchema)
}), z.object({
    DeleteKey: z.lazy(() => DeleteKeyActionSchema)
}), z.object({
    DeleteAccount: z.lazy(() => DeleteAccountActionSchema)
}), z.object({
    Delegate: z.lazy(() => SignedDelegateActionSchema)
}), z.object({
    DeployGlobalContract: z.lazy(() => DeployGlobalContractActionSchema)
}), z.object({
    UseGlobalContract: z.lazy(() => UseGlobalContractActionSchema)
})]);
export const ActionCreationConfigViewSchema = z.object({
    add_key_cost: AccessKeyCreationConfigViewSchema,
    create_account_cost: z.lazy(() => FeeSchema),
    delegate_cost: z.lazy(() => FeeSchema),
    delete_account_cost: z.lazy(() => FeeSchema),
    delete_key_cost: z.lazy(() => FeeSchema),
    deploy_contract_cost: z.lazy(() => FeeSchema),
    deploy_contract_cost_per_byte: z.lazy(() => FeeSchema),
    function_call_cost: z.lazy(() => FeeSchema),
    function_call_cost_per_byte: z.lazy(() => FeeSchema),
    stake_cost: z.lazy(() => FeeSchema),
    transfer_cost: z.lazy(() => FeeSchema)
});
export const ActionErrorSchema = z.object({
    index: z.union([z.number(), z.null()]).optional(),
    kind: z.lazy(() => ActionErrorKindSchema)
});
export const ActionErrorKindSchema = z.union([z.object({
    AccountAlreadyExists: z.object({
        account_id: AccountIdSchema
    })
}), z.object({
    AccountDoesNotExist: z.object({
        account_id: AccountIdSchema
    })
}), z.object({
    CreateAccountOnlyByRegistrar: z.object({
        account_id: AccountIdSchema,
        predecessor_id: AccountIdSchema,
        registrar_account_id: AccountIdSchema
    })
}), z.object({
    CreateAccountNotAllowed: z.object({
        account_id: AccountIdSchema,
        predecessor_id: AccountIdSchema
    })
}), z.object({
    ActorNoPermission: z.object({
        account_id: AccountIdSchema,
        actor_id: AccountIdSchema
    })
}), z.object({
    DeleteKeyDoesNotExist: z.object({
        account_id: AccountIdSchema,
        public_key: z.lazy(() => PublicKeySchema)
    })
}), z.object({
    AddKeyAlreadyExists: z.object({
        account_id: AccountIdSchema,
        public_key: z.lazy(() => PublicKeySchema)
    })
}), z.object({
    DeleteAccountStaking: z.object({
        account_id: AccountIdSchema
    })
}), z.object({
    LackBalanceForState: z.object({
        account_id: AccountIdSchema,
        amount: z.string()
    })
}), z.object({
    TriesToUnstake: z.object({
        account_id: AccountIdSchema
    })
}), z.object({
    TriesToStake: z.object({
        account_id: AccountIdSchema,
        balance: z.string(),
        locked: z.string(),
        stake: z.string()
    })
}), z.object({
    InsufficientStake: z.object({
        account_id: AccountIdSchema,
        minimum_stake: z.string(),
        stake: z.string()
    })
}), z.object({
    FunctionCallError: z.lazy(() => FunctionCallErrorSchema)
}), z.object({
    NewReceiptValidationError: z.lazy(() => ReceiptValidationErrorSchema)
}), z.object({
    OnlyImplicitAccountCreationAllowed: z.object({
        account_id: AccountIdSchema
    })
}), z.object({
    DeleteAccountWithLargeState: z.object({
        account_id: AccountIdSchema
    })
}), z.literal("DelegateActionInvalidSignature"), z.object({
    DelegateActionSenderDoesNotMatchTxReceiver: z.object({
        receiver_id: AccountIdSchema,
        sender_id: AccountIdSchema
    })
}), z.literal("DelegateActionExpired"), z.object({
    DelegateActionAccessKeyError: z.lazy(() => InvalidAccessKeyErrorSchema)
}), z.object({
    DelegateActionInvalidNonce: z.object({
        ak_nonce: z.number(),
        delegate_nonce: z.number()
    })
}), z.object({
    DelegateActionNonceTooLarge: z.object({
        delegate_nonce: z.number(),
        upper_bound: z.number()
    })
}), z.object({
    GlobalContractDoesNotExist: z.object({
        identifier: z.lazy(() => GlobalContractIdentifierSchema)
    })
})]);
export const ActionsValidationErrorSchema = z.union([z.literal("DeleteActionMustBeFinal"), z.object({
    TotalPrepaidGasExceeded: z.object({
        limit: z.number(),
        total_prepaid_gas: z.number()
    })
}), z.object({
    TotalNumberOfActionsExceeded: z.object({
        limit: z.number(),
        total_number_of_actions: z.number()
    })
}), z.object({
    AddKeyMethodNamesNumberOfBytesExceeded: z.object({
        limit: z.number(),
        total_number_of_bytes: z.number()
    })
}), z.object({
    AddKeyMethodNameLengthExceeded: z.object({
        length: z.number(),
        limit: z.number()
    })
}), z.literal("IntegerOverflow"), z.object({
    InvalidAccountId: z.object({
        account_id: z.string()
    })
}), z.object({
    ContractSizeExceeded: z.object({
        limit: z.number(),
        size: z.number()
    })
}), z.object({
    FunctionCallMethodNameLengthExceeded: z.object({
        length: z.number(),
        limit: z.number()
    })
}), z.object({
    FunctionCallArgumentsLengthExceeded: z.object({
        length: z.number(),
        limit: z.number()
    })
}), z.object({
    UnsuitableStakingKey: z.object({
        public_key: z.lazy(() => PublicKeySchema)
    })
}), z.literal("FunctionCallZeroAttachedGas"), z.literal("DelegateActionMustBeOnlyOne"), z.object({
    UnsupportedProtocolFeature: z.object({
        protocol_feature: z.string(),
        version: z.number()
    })
})]);
export const ActionViewSchema = z.union([z.literal("CreateAccount"), z.object({
    DeployContract: z.object({
        code: z.string()
    })
}), z.object({
    FunctionCall: z.object({
        args: z.string(),
        deposit: z.string(),
        gas: z.number(),
        method_name: z.string()
    })
}), z.object({
    Transfer: z.object({
        deposit: z.string()
    })
}), z.object({
    Stake: z.object({
        public_key: z.lazy(() => PublicKeySchema),
        stake: z.string()
    })
}), z.object({
    AddKey: z.object({
        access_key: AccessKeyViewSchema,
        public_key: z.lazy(() => PublicKeySchema)
    })
}), z.object({
    DeleteKey: z.object({
        public_key: z.lazy(() => PublicKeySchema)
    })
}), z.object({
    DeleteAccount: z.object({
        beneficiary_id: AccountIdSchema
    })
}), z.object({
    Delegate: z.object({
        delegate_action: z.lazy(() => DelegateActionSchema),
        signature: z.lazy(() => SignatureSchema)
    })
}), z.object({
    DeployGlobalContract: z.object({
        code: z.string()
    })
}), z.object({
    DeployGlobalContractByAccountId: z.object({
        code: z.string()
    })
}), z.object({
    UseGlobalContract: z.object({
        code_hash: z.lazy(() => CryptoHashSchema)
    })
}), z.object({
    UseGlobalContractByAccountId: z.object({
        account_id: AccountIdSchema
    })
})]);
export const AddKeyActionSchema = z.object({
    access_key: AccessKeySchema,
    public_key: z.lazy(() => PublicKeySchema)
});
export const BandwidthRequestSchema = z.object({
    requested_values_bitmap: z.lazy(() => BandwidthRequestBitmapSchema),
    to_shard: z.number()
});
export const BandwidthRequestBitmapSchema = z.object({
    data: z.array(z.number())
});
export const BandwidthRequestsSchema = z.object({
    V1: z.lazy(() => BandwidthRequestsV1Schema)
});
export const BandwidthRequestsV1Schema = z.object({
    requests: z.array(BandwidthRequestSchema)
});
export const BlockHeaderInnerLiteViewSchema = z.object({
    block_merkle_root: z.lazy(() => CryptoHashSchema),
    epoch_id: z.lazy(() => CryptoHashSchema),
    height: z.number(),
    next_bp_hash: z.lazy(() => CryptoHashSchema),
    next_epoch_id: z.lazy(() => CryptoHashSchema),
    outcome_root: z.lazy(() => CryptoHashSchema),
    prev_state_root: z.lazy(() => CryptoHashSchema),
    timestamp: z.number(),
    timestamp_nanosec: z.string()
});
export const BlockHeaderViewSchema = z.object({
    approvals: z.array(z.union([z.lazy(() => SignatureSchema), z.null()])),
    block_body_hash: z.union([z.lazy(() => CryptoHashSchema), z.null()]).optional(),
    block_merkle_root: z.lazy(() => CryptoHashSchema),
    block_ordinal: z.union([z.number(), z.null()]).optional(),
    challenges_result: z.array(z.lazy(() => SlashedValidatorSchema)),
    challenges_root: z.lazy(() => CryptoHashSchema),
    chunk_endorsements: z.union([z.array(z.array(z.number())), z.null()]).optional(),
    chunk_headers_root: z.lazy(() => CryptoHashSchema),
    chunk_mask: z.array(z.boolean()),
    chunk_receipts_root: z.lazy(() => CryptoHashSchema),
    chunk_tx_root: z.lazy(() => CryptoHashSchema),
    chunks_included: z.number(),
    epoch_id: z.lazy(() => CryptoHashSchema),
    epoch_sync_data_hash: z.union([z.lazy(() => CryptoHashSchema), z.null()]).optional(),
    gas_price: z.string(),
    hash: z.lazy(() => CryptoHashSchema),
    height: z.number(),
    last_ds_final_block: z.lazy(() => CryptoHashSchema),
    last_final_block: z.lazy(() => CryptoHashSchema),
    latest_protocol_version: z.number(),
    next_bp_hash: z.lazy(() => CryptoHashSchema),
    next_epoch_id: z.lazy(() => CryptoHashSchema),
    outcome_root: z.lazy(() => CryptoHashSchema),
    prev_hash: z.lazy(() => CryptoHashSchema),
    prev_height: z.union([z.number(), z.null()]).optional(),
    prev_state_root: z.lazy(() => CryptoHashSchema),
    random_value: z.lazy(() => CryptoHashSchema),
    rent_paid: z.string(),
    signature: z.lazy(() => SignatureSchema),
    timestamp: z.number(),
    timestamp_nanosec: z.string(),
    total_supply: z.string(),
    validator_proposals: z.array(z.lazy(() => ValidatorStakeViewSchema)),
    validator_reward: z.string()
});
export const BlockIdSchema = z.union([z.number(), z.lazy(() => CryptoHashSchema)]);
export const BlockStatusViewSchema = z.object({
    hash: z.lazy(() => CryptoHashSchema),
    height: z.number()
});
export const CallResultSchema = z.object({
    logs: z.array(z.string()),
    result: z.array(z.number())
});
export const CatchupStatusViewSchema = z.object({
    blocks_to_catchup: z.array(BlockStatusViewSchema),
    shard_sync_status: z.record(z.string(), z.string()),
    sync_block_hash: z.lazy(() => CryptoHashSchema),
    sync_block_height: z.number()
});
export const ChunkDistributionNetworkConfigSchema = z.object({
    enabled: z.boolean(),
    uris: z.lazy(() => ChunkDistributionUrisSchema)
});
export const ChunkDistributionUrisSchema = z.object({
    get: z.string(),
    set: z.string()
});
export const ChunkHeaderViewSchema = z.object({
    balance_burnt: z.string(),
    bandwidth_requests: z.union([BandwidthRequestsSchema, z.null()]).optional(),
    chunk_hash: z.lazy(() => CryptoHashSchema),
    congestion_info: z.union([z.lazy(() => CongestionInfoViewSchema), z.null()]).optional(),
    encoded_length: z.number(),
    encoded_merkle_root: z.lazy(() => CryptoHashSchema),
    gas_limit: z.number(),
    gas_used: z.number(),
    height_created: z.number(),
    height_included: z.number(),
    outcome_root: z.lazy(() => CryptoHashSchema),
    outgoing_receipts_root: z.lazy(() => CryptoHashSchema),
    prev_block_hash: z.lazy(() => CryptoHashSchema),
    prev_state_root: z.lazy(() => CryptoHashSchema),
    rent_paid: z.string(),
    shard_id: z.lazy(() => ShardIdSchema),
    signature: z.lazy(() => SignatureSchema),
    tx_root: z.lazy(() => CryptoHashSchema),
    validator_proposals: z.array(z.lazy(() => ValidatorStakeViewSchema)),
    validator_reward: z.string()
});
export const CompilationErrorSchema = z.union([z.object({
    CodeDoesNotExist: z.object({
        account_id: AccountIdSchema
    })
}), z.object({
    PrepareError: z.lazy(() => PrepareErrorSchema)
}), z.object({
    WasmerCompileError: z.object({
        msg: z.string()
    })
})]);
export const CongestionControlConfigViewSchema = z.object({
    allowed_shard_outgoing_gas: z.number(),
    max_congestion_incoming_gas: z.number(),
    max_congestion_memory_consumption: z.number(),
    max_congestion_missed_chunks: z.number(),
    max_congestion_outgoing_gas: z.number(),
    max_outgoing_gas: z.number(),
    max_tx_gas: z.number(),
    min_outgoing_gas: z.number(),
    min_tx_gas: z.number(),
    outgoing_receipts_big_size_limit: z.number(),
    outgoing_receipts_usual_size_limit: z.number(),
    reject_tx_congestion_threshold: z.number()
});
export const CongestionInfoViewSchema = z.object({
    allowed_shard: z.number(),
    buffered_receipts_gas: z.string(),
    delayed_receipts_gas: z.string(),
    receipt_bytes: z.number()
});
export const ContractCodeViewSchema = z.object({
    code_base64: z.string(),
    hash: z.lazy(() => CryptoHashSchema)
});
export const CostGasUsedSchema = z.object({
    cost: z.string(),
    cost_category: z.string(),
    gas_used: z.string()
});
export const CreateAccountActionSchema = z.record(z.string(), z.unknown());
export const CryptoHashSchema = z.string();
export const CurrentEpochValidatorInfoSchema = z.object({
    account_id: AccountIdSchema,
    is_slashed: z.boolean(),
    num_expected_blocks: z.number(),
    num_expected_chunks: z.number(),
    num_expected_chunks_per_shard: z.array(z.number()),
    num_expected_endorsements: z.number(),
    num_expected_endorsements_per_shard: z.array(z.number()),
    num_produced_blocks: z.number(),
    num_produced_chunks: z.number(),
    num_produced_chunks_per_shard: z.array(z.number()),
    num_produced_endorsements: z.number(),
    num_produced_endorsements_per_shard: z.array(z.number()),
    public_key: z.lazy(() => PublicKeySchema),
    shards: z.array(z.lazy(() => ShardIdSchema)),
    shards_endorsed: z.array(z.lazy(() => ShardIdSchema)),
    stake: z.string()
});
export const DataReceiptCreationConfigViewSchema = z.object({
    base_cost: z.lazy(() => FeeSchema),
    cost_per_byte: z.lazy(() => FeeSchema)
});
export const DataReceiverViewSchema = z.object({
    data_id: CryptoHashSchema,
    receiver_id: AccountIdSchema
});
export const DelegateActionSchema = z.object({
    actions: z.array(z.lazy(() => NonDelegateActionSchema)),
    max_block_height: z.number(),
    nonce: z.number(),
    public_key: z.lazy(() => PublicKeySchema),
    receiver_id: AccountIdSchema,
    sender_id: AccountIdSchema
});
export const DeleteAccountActionSchema = z.object({
    beneficiary_id: AccountIdSchema
});
export const DeleteKeyActionSchema = z.object({
    public_key: z.lazy(() => PublicKeySchema)
});
export const DeployContractActionSchema = z.object({
    code: z.string()
});
export const DeployGlobalContractActionSchema = z.object({
    code: z.string(),
    deploy_mode: z.lazy(() => GlobalContractDeployModeSchema)
});
export const DetailedDebugStatusSchema = z.object({
    block_production_delay_millis: z.number(),
    catchup_status: z.array(CatchupStatusViewSchema),
    current_head_status: BlockStatusViewSchema,
    current_header_head_status: BlockStatusViewSchema,
    network_info: z.lazy(() => NetworkInfoViewSchema),
    sync_status: z.string()
});
export const DirectionSchema = z.union([z.literal("Left"), z.literal("Right")]);
export const DumpConfigSchema = z.object({
    credentials_file: z.union([z.string(), z.null()]).optional(),
    iteration_delay: z.union([z.lazy(() => DurationAsStdSchemaProviderSchema), z.null()]).optional(),
    location: z.lazy(() => ExternalStorageLocationSchema),
    restart_dump_for_shards: z.union([z.array(z.lazy(() => ShardIdSchema)), z.null()]).optional()
});
export const DurationAsStdSchemaProviderSchema = z.object({
    nanos: z.number(),
    secs: z.number()
});
export const EpochIdSchema = CryptoHashSchema;
export const EpochSyncConfigSchema = z.object({
    disable_epoch_sync_for_bootstrapping: z.boolean(),
    epoch_sync_horizon: z.number(),
    ignore_epoch_sync_network_requests: z.boolean(),
    timeout_for_epoch_sync: DurationAsStdSchemaProviderSchema
});
export const ExecutionMetadataViewSchema = z.object({
    gas_profile: z.union([z.array(CostGasUsedSchema), z.null()]).optional(),
    version: z.number()
});
export const ExecutionOutcomeViewSchema = z.object({
    executor_id: AccountIdSchema,
    gas_burnt: z.number(),
    logs: z.array(z.string()),
    metadata: ExecutionMetadataViewSchema,
    receipt_ids: z.array(CryptoHashSchema),
    status: z.lazy(() => ExecutionStatusViewSchema),
    tokens_burnt: z.string()
});
export const ExecutionOutcomeWithIdViewSchema = z.object({
    block_hash: CryptoHashSchema,
    id: CryptoHashSchema,
    outcome: ExecutionOutcomeViewSchema,
    proof: z.array(z.lazy(() => MerklePathItemSchema))
});
export const ExecutionStatusViewSchema = z.union([z.literal("Unknown"), z.object({
    Failure: z.lazy(() => TxExecutionErrorSchema)
}), z.object({
    SuccessValue: z.string()
}), z.object({
    SuccessReceiptId: CryptoHashSchema
})]);
export const ExtCostsConfigViewSchema = z.object({
    alt_bn128_g1_multiexp_base: z.number(),
    alt_bn128_g1_multiexp_element: z.number(),
    alt_bn128_g1_sum_base: z.number(),
    alt_bn128_g1_sum_element: z.number(),
    alt_bn128_pairing_check_base: z.number(),
    alt_bn128_pairing_check_element: z.number(),
    base: z.number(),
    bls12381_g1_multiexp_base: z.number(),
    bls12381_g1_multiexp_element: z.number(),
    bls12381_g2_multiexp_base: z.number(),
    bls12381_g2_multiexp_element: z.number(),
    bls12381_map_fp_to_g1_base: z.number(),
    bls12381_map_fp_to_g1_element: z.number(),
    bls12381_map_fp2_to_g2_base: z.number(),
    bls12381_map_fp2_to_g2_element: z.number(),
    bls12381_p1_decompress_base: z.number(),
    bls12381_p1_decompress_element: z.number(),
    bls12381_p1_sum_base: z.number(),
    bls12381_p1_sum_element: z.number(),
    bls12381_p2_decompress_base: z.number(),
    bls12381_p2_decompress_element: z.number(),
    bls12381_p2_sum_base: z.number(),
    bls12381_p2_sum_element: z.number(),
    bls12381_pairing_base: z.number(),
    bls12381_pairing_element: z.number(),
    contract_compile_base: z.number(),
    contract_compile_bytes: z.number(),
    contract_loading_base: z.number(),
    contract_loading_bytes: z.number(),
    ecrecover_base: z.number(),
    ed25519_verify_base: z.number(),
    ed25519_verify_byte: z.number(),
    keccak256_base: z.number(),
    keccak256_byte: z.number(),
    keccak512_base: z.number(),
    keccak512_byte: z.number(),
    log_base: z.number(),
    log_byte: z.number(),
    promise_and_base: z.number(),
    promise_and_per_promise: z.number(),
    promise_return: z.number(),
    read_cached_trie_node: z.number(),
    read_memory_base: z.number(),
    read_memory_byte: z.number(),
    read_register_base: z.number(),
    read_register_byte: z.number(),
    ripemd160_base: z.number(),
    ripemd160_block: z.number(),
    sha256_base: z.number(),
    sha256_byte: z.number(),
    storage_has_key_base: z.number(),
    storage_has_key_byte: z.number(),
    storage_iter_create_from_byte: z.number(),
    storage_iter_create_prefix_base: z.number(),
    storage_iter_create_prefix_byte: z.number(),
    storage_iter_create_range_base: z.number(),
    storage_iter_create_to_byte: z.number(),
    storage_iter_next_base: z.number(),
    storage_iter_next_key_byte: z.number(),
    storage_iter_next_value_byte: z.number(),
    storage_large_read_overhead_base: z.number(),
    storage_large_read_overhead_byte: z.number(),
    storage_read_base: z.number(),
    storage_read_key_byte: z.number(),
    storage_read_value_byte: z.number(),
    storage_remove_base: z.number(),
    storage_remove_key_byte: z.number(),
    storage_remove_ret_value_byte: z.number(),
    storage_write_base: z.number(),
    storage_write_evicted_byte: z.number(),
    storage_write_key_byte: z.number(),
    storage_write_value_byte: z.number(),
    touching_trie_node: z.number(),
    utf8_decoding_base: z.number(),
    utf8_decoding_byte: z.number(),
    utf16_decoding_base: z.number(),
    utf16_decoding_byte: z.number(),
    validator_stake_base: z.number(),
    validator_total_stake_base: z.number(),
    write_memory_base: z.number(),
    write_memory_byte: z.number(),
    write_register_base: z.number(),
    write_register_byte: z.number(),
    yield_create_base: z.number(),
    yield_create_byte: z.number(),
    yield_resume_base: z.number(),
    yield_resume_byte: z.number()
});
export const ExternalStorageConfigSchema = z.object({
    external_storage_fallback_threshold: z.number(),
    location: z.lazy(() => ExternalStorageLocationSchema),
    num_concurrent_requests: z.number(),
    num_concurrent_requests_during_catchup: z.number()
});
export const ExternalStorageLocationSchema = z.union([z.object({
    S3: z.object({
        bucket: z.string(),
        region: z.string()
    })
}), z.object({
    Filesystem: z.object({
        root_dir: z.string()
    })
}), z.object({
    GCS: z.object({
        bucket: z.string()
    })
})]);
export const FeeSchema = z.object({
    execution: z.number(),
    send_not_sir: z.number(),
    send_sir: z.number()
});
export const FinalExecutionOutcomeViewSchema = z.object({
    receipts_outcome: z.array(ExecutionOutcomeWithIdViewSchema),
    status: z.lazy(() => FinalExecutionStatusSchema),
    transaction: z.lazy(() => SignedTransactionViewSchema),
    transaction_outcome: ExecutionOutcomeWithIdViewSchema
});
export const FinalExecutionOutcomeWithReceiptViewSchema = z.object({
    receipts: z.array(z.lazy(() => ReceiptViewSchema)),
    receipts_outcome: z.array(ExecutionOutcomeWithIdViewSchema),
    status: z.lazy(() => FinalExecutionStatusSchema),
    transaction: z.lazy(() => SignedTransactionViewSchema),
    transaction_outcome: ExecutionOutcomeWithIdViewSchema
});
export const FinalExecutionStatusSchema = z.union([z.literal("NotStarted"), z.literal("Started"), z.object({
    Failure: z.lazy(() => TxExecutionErrorSchema)
}), z.object({
    SuccessValue: z.string()
})]);
export const FinalitySchema = z.union([z.literal("optimistic"), z.literal("near-final"), z.literal("final")]);
export const FunctionCallActionSchema = z.object({
    args: z.string(),
    deposit: z.string(),
    gas: z.number(),
    method_name: z.string()
});
export const FunctionCallErrorSchema = z.union([z.union([z.literal("WasmUnknownError"), z.literal("_EVMError")]), z.object({
    CompilationError: CompilationErrorSchema
}), z.object({
    LinkError: z.object({
        msg: z.string()
    })
}), z.object({
    MethodResolveError: z.lazy(() => MethodResolveErrorSchema)
}), z.object({
    WasmTrap: z.lazy(() => WasmTrapSchema)
}), z.object({
    HostError: z.lazy(() => HostErrorSchema)
}), z.object({
    ExecutionError: z.string()
})]);
export const FunctionCallPermissionSchema = z.object({
    allowance: z.union([z.string(), z.null()]).optional(),
    method_names: z.array(z.string()),
    receiver_id: z.string()
});
export const GasKeyViewSchema = z.object({
    balance: z.number(),
    num_nonces: z.number(),
    permission: AccessKeyPermissionViewSchema
});
export const GCConfigSchema = z.object({
    gc_blocks_limit: z.number(),
    gc_fork_clean_step: z.number(),
    gc_num_epochs_to_keep: z.number(),
    gc_step_period: DurationAsStdSchemaProviderSchema
});
export const GenesisConfigSchema = z.object({
    avg_hidden_validator_seats_per_shard: z.array(z.number()),
    block_producer_kickout_threshold: z.number(),
    chain_id: z.string(),
    chunk_producer_assignment_changes_limit: z.number(),
    chunk_producer_kickout_threshold: z.number(),
    chunk_validator_only_kickout_threshold: z.number(),
    dynamic_resharding: z.boolean(),
    epoch_length: z.number(),
    fishermen_threshold: z.string(),
    gas_limit: z.number(),
    gas_price_adjustment_rate: z.array(z.number()),
    genesis_height: z.number(),
    genesis_time: z.string(),
    max_gas_price: z.string(),
    max_inflation_rate: z.array(z.number()),
    max_kickout_stake_perc: z.number(),
    min_gas_price: z.string(),
    minimum_stake_divisor: z.number(),
    minimum_stake_ratio: z.array(z.number()),
    minimum_validators_per_shard: z.number(),
    num_block_producer_seats: z.number(),
    num_block_producer_seats_per_shard: z.array(z.number()),
    num_blocks_per_year: z.number(),
    num_chunk_only_producer_seats: z.number(),
    num_chunk_producer_seats: z.number(),
    num_chunk_validator_seats: z.number(),
    online_max_threshold: z.array(z.number()),
    online_min_threshold: z.array(z.number()),
    protocol_reward_rate: z.array(z.number()),
    protocol_treasury_account: AccountIdSchema,
    protocol_upgrade_stake_threshold: z.array(z.number()),
    protocol_version: z.number(),
    shard_layout: z.lazy(() => ShardLayoutSchema),
    shuffle_shard_assignment_for_chunk_producers: z.boolean(),
    target_validator_mandates_per_shard: z.number(),
    total_supply: z.string(),
    transaction_validity_period: z.number(),
    use_production_config: z.boolean(),
    validators: z.array(AccountInfoSchema)
});
export const GenesisConfigRequestSchema = z.record(z.string(), z.unknown());
export const GlobalContractDeployModeSchema = z.union([z.literal("CodeHash"), z.literal("AccountId")]);
export const GlobalContractIdentifierSchema = z.union([z.object({
    CodeHash: CryptoHashSchema
}), z.object({
    AccountId: AccountIdSchema
})]);
export const HostErrorSchema = z.union([z.literal("BadUTF16"), z.literal("BadUTF8"), z.literal("GasExceeded"), z.literal("GasLimitExceeded"), z.literal("BalanceExceeded"), z.literal("EmptyMethodName"), z.object({
    GuestPanic: z.object({
        panic_msg: z.string()
    })
}), z.literal("IntegerOverflow"), z.object({
    InvalidPromiseIndex: z.object({
        promise_idx: z.number()
    })
}), z.literal("CannotAppendActionToJointPromise"), z.literal("CannotReturnJointPromise"), z.object({
    InvalidPromiseResultIndex: z.object({
        result_idx: z.number()
    })
}), z.object({
    InvalidRegisterId: z.object({
        register_id: z.number()
    })
}), z.object({
    IteratorWasInvalidated: z.object({
        iterator_index: z.number()
    })
}), z.literal("MemoryAccessViolation"), z.object({
    InvalidReceiptIndex: z.object({
        receipt_index: z.number()
    })
}), z.object({
    InvalidIteratorIndex: z.object({
        iterator_index: z.number()
    })
}), z.literal("InvalidAccountId"), z.literal("InvalidMethodName"), z.literal("InvalidPublicKey"), z.object({
    ProhibitedInView: z.object({
        method_name: z.string()
    })
}), z.object({
    NumberOfLogsExceeded: z.object({
        limit: z.number()
    })
}), z.object({
    KeyLengthExceeded: z.object({
        length: z.number(),
        limit: z.number()
    })
}), z.object({
    ValueLengthExceeded: z.object({
        length: z.number(),
        limit: z.number()
    })
}), z.object({
    TotalLogLengthExceeded: z.object({
        length: z.number(),
        limit: z.number()
    })
}), z.object({
    NumberPromisesExceeded: z.object({
        limit: z.number(),
        number_of_promises: z.number()
    })
}), z.object({
    NumberInputDataDependenciesExceeded: z.object({
        limit: z.number(),
        number_of_input_data_dependencies: z.number()
    })
}), z.object({
    ReturnedValueLengthExceeded: z.object({
        length: z.number(),
        limit: z.number()
    })
}), z.object({
    ContractSizeExceeded: z.object({
        limit: z.number(),
        size: z.number()
    })
}), z.object({
    Deprecated: z.object({
        method_name: z.string()
    })
}), z.object({
    ECRecoverError: z.object({
        msg: z.string()
    })
}), z.object({
    AltBn128InvalidInput: z.object({
        msg: z.string()
    })
}), z.object({
    Ed25519VerifyInvalidInput: z.object({
        msg: z.string()
    })
})]);
export const InvalidAccessKeyErrorSchema = z.union([z.object({
    AccessKeyNotFound: z.object({
        account_id: AccountIdSchema,
        public_key: z.lazy(() => PublicKeySchema)
    })
}), z.object({
    ReceiverMismatch: z.object({
        ak_receiver: z.string(),
        tx_receiver: AccountIdSchema
    })
}), z.object({
    MethodNameMismatch: z.object({
        method_name: z.string()
    })
}), z.literal("RequiresFullAccess"), z.object({
    NotEnoughAllowance: z.object({
        account_id: AccountIdSchema,
        allowance: z.string(),
        cost: z.string(),
        public_key: z.lazy(() => PublicKeySchema)
    })
}), z.literal("DepositWithFunctionCall")]);
export const InvalidTxErrorSchema = z.union([z.object({
    InvalidAccessKeyError: InvalidAccessKeyErrorSchema
}), z.object({
    InvalidSignerId: z.object({
        signer_id: z.string()
    })
}), z.object({
    SignerDoesNotExist: z.object({
        signer_id: AccountIdSchema
    })
}), z.object({
    InvalidNonce: z.object({
        ak_nonce: z.number(),
        tx_nonce: z.number()
    })
}), z.object({
    NonceTooLarge: z.object({
        tx_nonce: z.number(),
        upper_bound: z.number()
    })
}), z.object({
    InvalidReceiverId: z.object({
        receiver_id: z.string()
    })
}), z.literal("InvalidSignature"), z.object({
    NotEnoughBalance: z.object({
        balance: z.string(),
        cost: z.string(),
        signer_id: AccountIdSchema
    })
}), z.object({
    LackBalanceForState: z.object({
        amount: z.string(),
        signer_id: AccountIdSchema
    })
}), z.literal("CostOverflow"), z.literal("InvalidChain"), z.literal("Expired"), z.object({
    ActionsValidation: ActionsValidationErrorSchema
}), z.object({
    TransactionSizeExceeded: z.object({
        limit: z.number(),
        size: z.number()
    })
}), z.literal("InvalidTransactionVersion"), z.object({
    StorageError: z.lazy(() => StorageErrorSchema)
}), z.object({
    ShardCongested: z.object({
        congestion_level: z.number(),
        shard_id: z.number()
    })
}), z.object({
    ShardStuck: z.object({
        missed_chunks: z.number(),
        shard_id: z.number()
    })
})]);
export const JsonRpcRequest_for_blockSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("block"),
    params: z.lazy(() => RpcBlockRequestSchema)
});
export const JsonRpcRequest_for_broadcast_tx_asyncSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("broadcast_tx_async"),
    params: z.lazy(() => RpcSendTransactionRequestSchema)
});
export const JsonRpcRequest_for_broadcast_tx_commitSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("broadcast_tx_commit"),
    params: z.lazy(() => RpcSendTransactionRequestSchema)
});
export const JsonRpcRequest_for_changesSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("changes"),
    params: z.lazy(() => RpcStateChangesInBlockByTypeRequestSchema)
});
export const JsonRpcRequest_for_chunkSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("chunk"),
    params: z.lazy(() => RpcChunkRequestSchema)
});
export const JsonRpcRequest_for_client_configSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("client_config"),
    params: z.lazy(() => RpcClientConfigRequestSchema)
});
export const JsonRpcRequest_for_EXPERIMENTAL_changesSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("EXPERIMENTAL_changes"),
    params: z.lazy(() => RpcStateChangesInBlockByTypeRequestSchema)
});
export const JsonRpcRequest_for_EXPERIMENTAL_changes_in_blockSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("EXPERIMENTAL_changes_in_block"),
    params: z.lazy(() => RpcStateChangesInBlockRequestSchema)
});
export const JsonRpcRequest_for_EXPERIMENTAL_congestion_levelSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("EXPERIMENTAL_congestion_level"),
    params: z.lazy(() => RpcCongestionLevelRequestSchema)
});
export const JsonRpcRequest_for_EXPERIMENTAL_genesis_configSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("EXPERIMENTAL_genesis_config"),
    params: GenesisConfigRequestSchema
});
export const JsonRpcRequest_for_EXPERIMENTAL_light_client_block_proofSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("EXPERIMENTAL_light_client_block_proof"),
    params: z.lazy(() => RpcLightClientBlockProofRequestSchema)
});
export const JsonRpcRequest_for_EXPERIMENTAL_light_client_proofSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("EXPERIMENTAL_light_client_proof"),
    params: z.lazy(() => RpcLightClientExecutionProofRequestSchema)
});
export const JsonRpcRequest_for_EXPERIMENTAL_maintenance_windowsSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("EXPERIMENTAL_maintenance_windows"),
    params: z.lazy(() => RpcMaintenanceWindowsRequestSchema)
});
export const JsonRpcRequest_for_EXPERIMENTAL_protocol_configSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("EXPERIMENTAL_protocol_config"),
    params: z.lazy(() => RpcProtocolConfigRequestSchema)
});
export const JsonRpcRequest_for_EXPERIMENTAL_receiptSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("EXPERIMENTAL_receipt"),
    params: z.lazy(() => RpcReceiptRequestSchema)
});
export const JsonRpcRequest_for_EXPERIMENTAL_split_storage_infoSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("EXPERIMENTAL_split_storage_info"),
    params: z.lazy(() => RpcSplitStorageInfoRequestSchema)
});
export const JsonRpcRequest_for_EXPERIMENTAL_tx_statusSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("EXPERIMENTAL_tx_status"),
    params: z.lazy(() => RpcTransactionStatusRequestSchema)
});
export const JsonRpcRequest_for_EXPERIMENTAL_validators_orderedSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("EXPERIMENTAL_validators_ordered"),
    params: z.lazy(() => RpcValidatorsOrderedRequestSchema)
});
export const JsonRpcRequest_for_gas_priceSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("gas_price"),
    params: z.lazy(() => RpcGasPriceRequestSchema)
});
export const JsonRpcRequest_for_healthSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("health"),
    params: z.lazy(() => RpcHealthRequestSchema)
});
export const JsonRpcRequest_for_light_client_proofSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("light_client_proof"),
    params: z.lazy(() => RpcLightClientExecutionProofRequestSchema)
});
export const JsonRpcRequest_for_network_infoSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("network_info"),
    params: z.lazy(() => RpcNetworkInfoRequestSchema)
});
export const JsonRpcRequest_for_next_light_client_blockSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("next_light_client_block"),
    params: z.lazy(() => RpcLightClientNextBlockRequestSchema)
});
export const JsonRpcRequest_for_querySchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("query"),
    params: z.lazy(() => RpcQueryRequestSchema)
});
export const JsonRpcRequest_for_send_txSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("send_tx"),
    params: z.lazy(() => RpcSendTransactionRequestSchema)
});
export const JsonRpcRequest_for_statusSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("status"),
    params: z.lazy(() => RpcStatusRequestSchema)
});
export const JsonRpcRequest_for_txSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("tx"),
    params: z.lazy(() => RpcTransactionStatusRequestSchema)
});
export const JsonRpcRequest_for_validatorsSchema = z.object({
    id: z.string(),
    jsonrpc: z.string(),
    method: z.literal("validators"),
    params: z.lazy(() => RpcValidatorRequestSchema)
});
export const JsonRpcResponse_for_Array_of_Range_of_uint64_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.array(z.lazy(() => Range_of_uint64Schema))
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_Array_of_ValidatorStakeView_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.array(z.lazy(() => ValidatorStakeViewSchema))
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_CryptoHash_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: CryptoHashSchema
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_GenesisConfig_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: GenesisConfigSchema
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_Nullable_RpcHealthResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.union([z.lazy(() => RpcHealthResponseSchema), z.null()])
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcBlockResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcBlockResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcChunkResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcChunkResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcClientConfigResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcClientConfigResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcCongestionLevelResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcCongestionLevelResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcGasPriceResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcGasPriceResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcLightClientBlockProofResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcLightClientBlockProofResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcLightClientExecutionProofResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcLightClientExecutionProofResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcLightClientNextBlockResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcLightClientNextBlockResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcNetworkInfoResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcNetworkInfoResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcProtocolConfigResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcProtocolConfigResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcQueryResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcQueryResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcReceiptResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcReceiptResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcSplitStorageInfoResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcSplitStorageInfoResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcStateChangesInBlockByTypeResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcStateChangesInBlockByTypeResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcStateChangesInBlockResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcStateChangesInBlockResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcStatusResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcStatusResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcTransactionResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcTransactionResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const JsonRpcResponse_for_RpcValidatorResponse_and_RpcErrorSchema = z.object({
    id: z.string(),
    jsonrpc: z.string()
}).and(z.union([z.object({
    result: z.lazy(() => RpcValidatorResponseSchema)
}), z.object({
    error: z.lazy(() => RpcErrorSchema)
})]));
export const KnownProducerViewSchema = z.object({
    account_id: AccountIdSchema,
    next_hops: z.union([z.array(z.lazy(() => PublicKeySchema)), z.null()]).optional(),
    peer_id: z.lazy(() => PublicKeySchema)
});
export const LightClientBlockLiteViewSchema = z.object({
    inner_lite: BlockHeaderInnerLiteViewSchema,
    inner_rest_hash: CryptoHashSchema,
    prev_block_hash: CryptoHashSchema
});
export const LimitConfigSchema = z.object({
    account_id_validity_rules_version: AccountIdValidityRulesVersionSchema,
    initial_memory_pages: z.number(),
    max_actions_per_receipt: z.number(),
    max_arguments_length: z.number(),
    max_contract_size: z.number(),
    max_functions_number_per_contract: z.union([z.number(), z.null()]).optional(),
    max_gas_burnt: z.number(),
    max_length_method_name: z.number(),
    max_length_returned_data: z.number(),
    max_length_storage_key: z.number(),
    max_length_storage_value: z.number(),
    max_locals_per_contract: z.union([z.number(), z.null()]).optional(),
    max_memory_pages: z.number(),
    max_number_bytes_method_names: z.number(),
    max_number_input_data_dependencies: z.number(),
    max_number_logs: z.number(),
    max_number_registers: z.number(),
    max_promises_per_function_call_action: z.number(),
    max_receipt_size: z.number(),
    max_register_size: z.number(),
    max_stack_height: z.number(),
    max_total_log_length: z.number(),
    max_total_prepaid_gas: z.number(),
    max_transaction_size: z.number(),
    max_yield_payload_size: z.number(),
    per_receipt_storage_proof_size_limit: z.number(),
    registers_memory_limit: z.number(),
    yield_timeout_length_in_blocks: z.number()
});
export const LogSummaryStyleSchema = z.union([z.literal("plain"), z.literal("colored")]);
export const MerklePathItemSchema = z.object({
    direction: DirectionSchema,
    hash: CryptoHashSchema
});
export const MethodResolveErrorSchema = z.union([z.literal("MethodEmptyName"), z.literal("MethodNotFound"), z.literal("MethodInvalidSignature")]);
export const MissingTrieValueSchema = z.object({
    context: z.lazy(() => MissingTrieValueContextSchema),
    hash: CryptoHashSchema
});
export const MissingTrieValueContextSchema = z.union([z.literal("TrieIterator"), z.literal("TriePrefetchingStorage"), z.literal("TrieMemoryPartialStorage"), z.literal("TrieStorage")]);
export const MutableConfigValueSchema = z.string();
export const NetworkInfoViewSchema = z.object({
    connected_peers: z.array(z.lazy(() => PeerInfoViewSchema)),
    known_producers: z.array(KnownProducerViewSchema),
    num_connected_peers: z.number(),
    peer_max_count: z.number(),
    tier1_accounts_data: z.array(AccountDataViewSchema),
    tier1_accounts_keys: z.array(z.lazy(() => PublicKeySchema)),
    tier1_connections: z.array(z.lazy(() => PeerInfoViewSchema))
});
export const NextEpochValidatorInfoSchema = z.object({
    account_id: AccountIdSchema,
    public_key: z.lazy(() => PublicKeySchema),
    shards: z.array(z.lazy(() => ShardIdSchema)),
    stake: z.string()
});
export const NonDelegateActionSchema = ActionSchema;
export const PeerIdSchema = z.lazy(() => PublicKeySchema);
export const PeerInfoViewSchema = z.object({
    account_id: z.union([AccountIdSchema, z.null()]).optional(),
    addr: z.string(),
    archival: z.boolean(),
    block_hash: z.union([CryptoHashSchema, z.null()]).optional(),
    connection_established_time_millis: z.number(),
    height: z.union([z.number(), z.null()]).optional(),
    is_highest_block_invalid: z.boolean(),
    is_outbound_peer: z.boolean(),
    last_time_peer_requested_millis: z.number(),
    last_time_received_message_millis: z.number(),
    nonce: z.number(),
    peer_id: z.lazy(() => PublicKeySchema),
    received_bytes_per_sec: z.number(),
    sent_bytes_per_sec: z.number(),
    tracked_shards: z.array(z.lazy(() => ShardIdSchema))
});
export const PrepareErrorSchema = z.union([z.literal("Serialization"), z.literal("Deserialization"), z.literal("InternalMemoryDeclared"), z.literal("GasInstrumentation"), z.literal("StackHeightInstrumentation"), z.literal("Instantiate"), z.literal("Memory"), z.literal("TooManyFunctions"), z.literal("TooManyLocals")]);
export const PublicKeySchema = z.string();
export const Range_of_uint64Schema = z.object({
    end: z.number(),
    start: z.number()
});
export const ReceiptEnumViewSchema = z.union([z.object({
    Action: z.object({
        actions: z.array(ActionViewSchema),
        gas_price: z.string(),
        input_data_ids: z.array(CryptoHashSchema),
        is_promise_yield: z.boolean(),
        output_data_receivers: z.array(DataReceiverViewSchema),
        signer_id: AccountIdSchema,
        signer_public_key: PublicKeySchema
    })
}), z.object({
    Data: z.object({
        data: z.union([z.string(), z.null()]),
        data_id: CryptoHashSchema,
        is_promise_resume: z.boolean()
    })
}), z.object({
    GlobalContractDistribution: z.object({
        already_delivered_shards: z.array(z.lazy(() => ShardIdSchema)),
        code: z.string(),
        id: GlobalContractIdentifierSchema,
        target_shard: z.lazy(() => ShardIdSchema)
    })
})]);
export const ReceiptValidationErrorSchema = z.union([z.object({
    InvalidPredecessorId: z.object({
        account_id: z.string()
    })
}), z.object({
    InvalidReceiverId: z.object({
        account_id: z.string()
    })
}), z.object({
    InvalidSignerId: z.object({
        account_id: z.string()
    })
}), z.object({
    InvalidDataReceiverId: z.object({
        account_id: z.string()
    })
}), z.object({
    ReturnedValueLengthExceeded: z.object({
        length: z.number(),
        limit: z.number()
    })
}), z.object({
    NumberInputDataDependenciesExceeded: z.object({
        limit: z.number(),
        number_of_input_data_dependencies: z.number()
    })
}), z.object({
    ActionsValidation: ActionsValidationErrorSchema
}), z.object({
    ReceiptSizeExceeded: z.object({
        limit: z.number(),
        size: z.number()
    })
})]);
export const ReceiptViewSchema = z.object({
    predecessor_id: AccountIdSchema,
    priority: z.number(),
    receipt: ReceiptEnumViewSchema,
    receipt_id: CryptoHashSchema,
    receiver_id: AccountIdSchema
});
export const RpcBlockRequestSchema = z.union([z.object({
    block_id: BlockIdSchema
}), z.object({
    finality: FinalitySchema
}), z.object({
    sync_checkpoint: z.lazy(() => SyncCheckpointSchema)
})]);
export const RpcBlockResponseSchema = z.object({
    author: AccountIdSchema,
    chunks: z.array(ChunkHeaderViewSchema),
    header: BlockHeaderViewSchema
});
export const RpcChunkRequestSchema = z.union([z.object({
    block_id: BlockIdSchema,
    shard_id: z.lazy(() => ShardIdSchema)
}), z.object({
    chunk_id: CryptoHashSchema
})]);
export const RpcChunkResponseSchema = z.object({
    author: AccountIdSchema,
    header: ChunkHeaderViewSchema,
    receipts: z.array(ReceiptViewSchema),
    transactions: z.array(z.lazy(() => SignedTransactionViewSchema))
});
export const RpcClientConfigRequestSchema = z.record(z.string(), z.unknown());
export const RpcClientConfigResponseSchema = z.object({
    archive: z.boolean(),
    block_fetch_horizon: z.number(),
    block_header_fetch_horizon: z.number(),
    block_production_tracking_delay: z.array(z.number()),
    catchup_step_period: z.array(z.number()),
    chain_id: z.string(),
    chunk_distribution_network: z.union([ChunkDistributionNetworkConfigSchema, z.null()]).optional(),
    chunk_request_retry_period: z.array(z.number()),
    chunk_wait_mult: z.array(z.number()),
    client_background_migration_threads: z.number(),
    doomslug_step_period: z.array(z.number()),
    enable_multiline_logging: z.boolean(),
    enable_statistics_export: z.boolean(),
    epoch_length: z.number(),
    epoch_sync: EpochSyncConfigSchema,
    expected_shutdown: MutableConfigValueSchema,
    gc: GCConfigSchema,
    header_sync_expected_height_per_second: z.number(),
    header_sync_initial_timeout: z.array(z.number()),
    header_sync_progress_timeout: z.array(z.number()),
    header_sync_stall_ban_timeout: z.array(z.number()),
    log_summary_period: z.array(z.number()),
    log_summary_style: LogSummaryStyleSchema,
    max_block_production_delay: z.array(z.number()),
    max_block_wait_delay: z.array(z.number()),
    max_gas_burnt_view: z.union([z.number(), z.null()]).optional(),
    min_block_production_delay: z.array(z.number()),
    min_num_peers: z.number(),
    num_block_producer_seats: z.number(),
    orphan_state_witness_max_size: z.number(),
    orphan_state_witness_pool_size: z.number(),
    produce_chunk_add_transactions_time_limit: z.string(),
    produce_empty_blocks: z.boolean(),
    resharding_config: MutableConfigValueSchema,
    rpc_addr: z.union([z.string(), z.null()]).optional(),
    save_invalid_witnesses: z.boolean(),
    save_latest_witnesses: z.boolean(),
    save_trie_changes: z.boolean(),
    save_tx_outcomes: z.boolean(),
    skip_sync_wait: z.boolean(),
    state_sync: z.lazy(() => StateSyncConfigSchema),
    state_sync_enabled: z.boolean(),
    state_sync_external_backoff: z.array(z.number()),
    state_sync_external_timeout: z.array(z.number()),
    state_sync_p2p_timeout: z.array(z.number()),
    state_sync_retry_backoff: z.array(z.number()),
    sync_check_period: z.array(z.number()),
    sync_height_threshold: z.number(),
    sync_max_block_requests: z.number(),
    sync_step_period: z.array(z.number()),
    tracked_shards_config: z.lazy(() => TrackedShardsConfigSchema),
    transaction_pool_size_limit: z.union([z.number(), z.null()]).optional(),
    transaction_request_handler_threads: z.number(),
    trie_viewer_state_size_limit: z.union([z.number(), z.null()]).optional(),
    ttl_account_id_router: z.array(z.number()),
    tx_routing_height_horizon: z.number(),
    version: z.lazy(() => VersionSchema),
    view_client_threads: z.number(),
    view_client_throttle_period: z.array(z.number())
});
export const RpcCongestionLevelRequestSchema = z.union([z.object({
    block_id: BlockIdSchema,
    shard_id: z.lazy(() => ShardIdSchema)
}), z.object({
    chunk_id: CryptoHashSchema
})]);
export const RpcCongestionLevelResponseSchema = z.object({
    congestion_level: z.number()
});
export const RpcErrorSchema = z.object({
    cause: z.unknown().optional(),
    code: z.number(),
    data: z.unknown().optional(),
    message: z.string(),
    name: z.unknown().optional()
}).and(z.union([z.object({
    cause: z.lazy(() => RpcRequestValidationErrorKindSchema),
    name: z.literal("REQUEST_VALIDATION_ERROR")
}), z.object({
    cause: z.unknown(),
    name: z.literal("HANDLER_ERROR")
}), z.object({
    cause: z.unknown(),
    name: z.literal("INTERNAL_ERROR")
})]));
export const RpcGasPriceRequestSchema = z.object({
    block_id: z.union([BlockIdSchema, z.null()]).optional()
});
export const RpcGasPriceResponseSchema = z.object({
    gas_price: z.string()
});
export const RpcHealthRequestSchema = z.record(z.string(), z.unknown());
export const RpcHealthResponseSchema = z.record(z.string(), z.unknown());
export const RpcKnownProducerSchema = z.object({
    account_id: AccountIdSchema,
    addr: z.union([z.string(), z.null()]).optional(),
    peer_id: PeerIdSchema
});
export const RpcLightClientBlockProofRequestSchema = z.object({
    block_hash: CryptoHashSchema,
    light_client_head: CryptoHashSchema
});
export const RpcLightClientBlockProofResponseSchema = z.object({
    block_header_lite: LightClientBlockLiteViewSchema,
    block_proof: z.array(MerklePathItemSchema)
});
export const RpcLightClientExecutionProofRequestSchema = z.object({
    light_client_head: CryptoHashSchema
}).and(z.union([z.object({
    sender_id: AccountIdSchema,
    transaction_hash: CryptoHashSchema,
    type: z.literal("transaction")
}), z.object({
    receipt_id: CryptoHashSchema,
    receiver_id: AccountIdSchema,
    type: z.literal("receipt")
})]));
export const RpcLightClientExecutionProofResponseSchema = z.object({
    block_header_lite: LightClientBlockLiteViewSchema,
    block_proof: z.array(MerklePathItemSchema),
    outcome_proof: ExecutionOutcomeWithIdViewSchema,
    outcome_root_proof: z.array(MerklePathItemSchema)
});
export const RpcLightClientNextBlockRequestSchema = z.object({
    last_block_hash: CryptoHashSchema
});
export const RpcLightClientNextBlockResponseSchema = z.object({
    approvals_after_next: z.array(z.union([z.lazy(() => SignatureSchema), z.null()])).optional(),
    inner_lite: BlockHeaderInnerLiteViewSchema.optional(),
    inner_rest_hash: CryptoHashSchema.optional(),
    next_block_inner_hash: CryptoHashSchema.optional(),
    next_bps: z.union([z.array(z.lazy(() => ValidatorStakeViewSchema)), z.null()]).optional(),
    prev_block_hash: CryptoHashSchema.optional()
});
export const RpcMaintenanceWindowsRequestSchema = z.object({
    account_id: AccountIdSchema
});
export const RpcNetworkInfoRequestSchema = z.record(z.string(), z.unknown());
export const RpcNetworkInfoResponseSchema = z.object({
    active_peers: z.array(z.lazy(() => RpcPeerInfoSchema)),
    known_producers: z.array(RpcKnownProducerSchema),
    num_active_peers: z.number(),
    peer_max_count: z.number(),
    received_bytes_per_sec: z.number(),
    sent_bytes_per_sec: z.number()
});
export const RpcPeerInfoSchema = z.object({
    account_id: z.union([AccountIdSchema, z.null()]).optional(),
    addr: z.union([z.string(), z.null()]).optional(),
    id: PeerIdSchema
});
export const RpcProtocolConfigRequestSchema = z.union([z.object({
    block_id: BlockIdSchema
}), z.object({
    finality: FinalitySchema
}), z.object({
    sync_checkpoint: z.lazy(() => SyncCheckpointSchema)
})]);
export const RpcProtocolConfigResponseSchema = z.object({
    avg_hidden_validator_seats_per_shard: z.array(z.number()),
    block_producer_kickout_threshold: z.number(),
    chain_id: z.string(),
    chunk_producer_kickout_threshold: z.number(),
    chunk_validator_only_kickout_threshold: z.number(),
    dynamic_resharding: z.boolean(),
    epoch_length: z.number(),
    fishermen_threshold: z.string(),
    gas_limit: z.number(),
    gas_price_adjustment_rate: z.array(z.number()),
    genesis_height: z.number(),
    genesis_time: z.string(),
    max_gas_price: z.string(),
    max_inflation_rate: z.array(z.number()),
    max_kickout_stake_perc: z.number(),
    min_gas_price: z.string(),
    minimum_stake_divisor: z.number(),
    minimum_stake_ratio: z.array(z.number()),
    minimum_validators_per_shard: z.number(),
    num_block_producer_seats: z.number(),
    num_block_producer_seats_per_shard: z.array(z.number()),
    num_blocks_per_year: z.number(),
    online_max_threshold: z.array(z.number()),
    online_min_threshold: z.array(z.number()),
    protocol_reward_rate: z.array(z.number()),
    protocol_treasury_account: AccountIdSchema,
    protocol_upgrade_stake_threshold: z.array(z.number()),
    protocol_version: z.number(),
    runtime_config: z.lazy(() => RuntimeConfigViewSchema),
    shard_layout: z.lazy(() => ShardLayoutSchema),
    shuffle_shard_assignment_for_chunk_producers: z.boolean(),
    target_validator_mandates_per_shard: z.number(),
    transaction_validity_period: z.number()
});
export const RpcQueryRequestSchema = z.union([z.object({
    block_id: BlockIdSchema
}), z.object({
    finality: FinalitySchema
}), z.object({
    sync_checkpoint: z.lazy(() => SyncCheckpointSchema)
})]).and(z.union([z.object({
    account_id: AccountIdSchema,
    request_type: z.literal("view_account")
}), z.object({
    account_id: AccountIdSchema,
    request_type: z.literal("view_code")
}), z.object({
    account_id: AccountIdSchema,
    include_proof: z.boolean().optional(),
    prefix_base64: z.string(),
    request_type: z.literal("view_state")
}), z.object({
    account_id: AccountIdSchema,
    public_key: PublicKeySchema,
    request_type: z.literal("view_access_key")
}), z.object({
    account_id: AccountIdSchema,
    request_type: z.literal("view_access_key_list")
}), z.object({
    account_id: AccountIdSchema,
    args_base64: z.string(),
    method_name: z.string(),
    request_type: z.literal("call_function")
}), z.object({
    code_hash: CryptoHashSchema,
    request_type: z.literal("view_global_contract_code")
}), z.object({
    account_id: AccountIdSchema,
    request_type: z.literal("view_global_contract_code_by_account_id")
})]));
export const RpcQueryResponseSchema = z.union([z.object({
    block_hash: CryptoHashSchema,
    block_height: z.number()
}), AccountViewSchema, ContractCodeViewSchema, z.lazy(() => ViewStateResultSchema), CallResultSchema, AccessKeyViewSchema, AccessKeyListSchema]);
export const RpcReceiptRequestSchema = z.object({
    receipt_id: CryptoHashSchema
});
export const RpcReceiptResponseSchema = z.object({
    predecessor_id: AccountIdSchema,
    priority: z.number(),
    receipt: ReceiptEnumViewSchema,
    receipt_id: CryptoHashSchema,
    receiver_id: AccountIdSchema
});
export const RpcRequestValidationErrorKindSchema = z.union([z.object({
    info: z.object({
        method_name: z.string()
    }),
    name: z.literal("METHOD_NOT_FOUND")
}), z.object({
    info: z.object({
        error_message: z.string()
    }),
    name: z.literal("PARSE_ERROR")
})]);
export const RpcSendTransactionRequestSchema = z.object({
    signed_tx_base64: z.lazy(() => SignedTransactionSchema),
    wait_until: z.lazy(() => TxExecutionStatusSchema)
});
export const RpcSplitStorageInfoRequestSchema = z.record(z.string(), z.unknown());
export const RpcSplitStorageInfoResponseSchema = z.object({
    cold_head_height: z.union([z.number(), z.null()]).optional(),
    final_head_height: z.union([z.number(), z.null()]).optional(),
    head_height: z.union([z.number(), z.null()]).optional(),
    hot_db_kind: z.union([z.string(), z.null()]).optional()
});
export const RpcStateChangesInBlockByTypeRequestSchema = z.union([z.object({
    block_id: BlockIdSchema
}), z.object({
    finality: FinalitySchema
}), z.object({
    sync_checkpoint: z.lazy(() => SyncCheckpointSchema)
})]).and(z.union([z.object({
    account_ids: z.array(AccountIdSchema),
    changes_type: z.literal("account_changes")
}), z.object({
    changes_type: z.literal("single_access_key_changes"),
    keys: z.array(AccountWithPublicKeySchema)
}), z.object({
    changes_type: z.literal("single_gas_key_changes"),
    keys: z.array(AccountWithPublicKeySchema)
}), z.object({
    account_ids: z.array(AccountIdSchema),
    changes_type: z.literal("all_access_key_changes")
}), z.object({
    account_ids: z.array(AccountIdSchema),
    changes_type: z.literal("all_gas_key_changes")
}), z.object({
    account_ids: z.array(AccountIdSchema),
    changes_type: z.literal("contract_code_changes")
}), z.object({
    account_ids: z.array(AccountIdSchema),
    changes_type: z.literal("data_changes"),
    key_prefix_base64: z.string()
})]));
export const RpcStateChangesInBlockByTypeResponseSchema = z.object({
    block_hash: CryptoHashSchema,
    changes: z.array(z.lazy(() => StateChangeKindViewSchema))
});
export const RpcStateChangesInBlockRequestSchema = z.union([z.object({
    block_id: BlockIdSchema
}), z.object({
    finality: FinalitySchema
}), z.object({
    sync_checkpoint: z.lazy(() => SyncCheckpointSchema)
})]);
export const RpcStateChangesInBlockResponseSchema = z.object({
    block_hash: CryptoHashSchema,
    changes: z.array(z.lazy(() => StateChangeWithCauseViewSchema))
});
export const RpcStatusRequestSchema = z.record(z.string(), z.unknown());
export const RpcStatusResponseSchema = z.object({
    chain_id: z.string(),
    detailed_debug_status: z.union([DetailedDebugStatusSchema, z.null()]).optional(),
    genesis_hash: CryptoHashSchema,
    latest_protocol_version: z.number(),
    node_key: z.union([PublicKeySchema, z.null()]).optional(),
    node_public_key: PublicKeySchema,
    protocol_version: z.number(),
    rpc_addr: z.union([z.string(), z.null()]).optional(),
    sync_info: z.lazy(() => StatusSyncInfoSchema),
    uptime_sec: z.number(),
    validator_account_id: z.union([AccountIdSchema, z.null()]).optional(),
    validator_public_key: z.union([PublicKeySchema, z.null()]).optional(),
    validators: z.array(z.lazy(() => ValidatorInfoSchema)),
    version: z.lazy(() => VersionSchema)
});
export const RpcTransactionResponseSchema = z.union([z.object({
    final_execution_status: z.lazy(() => TxExecutionStatusSchema)
}), FinalExecutionOutcomeWithReceiptViewSchema, FinalExecutionOutcomeViewSchema]);
export const RpcTransactionStatusRequestSchema = z.union([z.object({
    wait_until: z.lazy(() => TxExecutionStatusSchema)
}), z.object({
    signed_tx_base64: z.lazy(() => SignedTransactionSchema)
}), z.object({
    sender_account_id: AccountIdSchema,
    tx_hash: CryptoHashSchema
})]);
export const RpcValidatorRequestSchema = z.union([z.literal("latest"), z.object({
    epoch_id: EpochIdSchema
}), z.object({
    block_id: BlockIdSchema
})]);
export const RpcValidatorResponseSchema = z.object({
    current_fishermen: z.array(z.lazy(() => ValidatorStakeViewSchema)),
    current_proposals: z.array(z.lazy(() => ValidatorStakeViewSchema)),
    current_validators: z.array(CurrentEpochValidatorInfoSchema),
    epoch_height: z.number(),
    epoch_start_height: z.number(),
    next_fishermen: z.array(z.lazy(() => ValidatorStakeViewSchema)),
    next_validators: z.array(NextEpochValidatorInfoSchema),
    prev_epoch_kickout: z.array(z.lazy(() => ValidatorKickoutViewSchema))
});
export const RpcValidatorsOrderedRequestSchema = z.object({
    block_id: z.union([BlockIdSchema, z.null()]).optional()
});
export const RuntimeConfigViewSchema = z.object({
    account_creation_config: AccountCreationConfigViewSchema,
    congestion_control_config: CongestionControlConfigViewSchema,
    storage_amount_per_byte: z.string(),
    transaction_costs: z.lazy(() => RuntimeFeesConfigViewSchema),
    wasm_config: z.lazy(() => VMConfigViewSchema),
    witness_config: z.lazy(() => WitnessConfigViewSchema)
});
export const RuntimeFeesConfigViewSchema = z.object({
    action_creation_config: ActionCreationConfigViewSchema,
    action_receipt_creation_config: FeeSchema,
    burnt_gas_reward: z.array(z.number()),
    data_receipt_creation_config: DataReceiptCreationConfigViewSchema,
    pessimistic_gas_price_inflation_ratio: z.array(z.number()),
    storage_usage_config: z.lazy(() => StorageUsageConfigViewSchema)
});
export const ShardIdSchema = z.number();
export const ShardLayoutSchema = z.union([z.object({
    V0: z.lazy(() => ShardLayoutV0Schema)
}), z.object({
    V1: z.lazy(() => ShardLayoutV1Schema)
}), z.object({
    V2: z.lazy(() => ShardLayoutV2Schema)
})]);
export const ShardLayoutV0Schema = z.object({
    num_shards: z.number(),
    version: z.number()
});
export const ShardLayoutV1Schema = z.object({
    boundary_accounts: z.array(AccountIdSchema),
    shards_split_map: z.union([z.array(z.array(ShardIdSchema)), z.null()]).optional(),
    to_parent_shard_map: z.union([z.array(ShardIdSchema), z.null()]).optional(),
    version: z.number()
});
export const ShardLayoutV2Schema = z.object({
    boundary_accounts: z.array(AccountIdSchema),
    id_to_index_map: z.record(z.string(), z.number()),
    index_to_id_map: z.record(z.string(), ShardIdSchema),
    shard_ids: z.array(ShardIdSchema),
    shards_parent_map: z.union([z.record(z.string(), ShardIdSchema), z.null()]).optional(),
    shards_split_map: z.union([z.record(z.string(), z.array(ShardIdSchema)), z.null()]).optional(),
    version: z.number()
});
export const ShardUIdSchema = z.object({
    shard_id: z.number(),
    version: z.number()
});
export const SignatureSchema = z.string();
export const SignedDelegateActionSchema = z.object({
    delegate_action: DelegateActionSchema,
    signature: SignatureSchema
});
export const SignedTransactionSchema = z.string();
export const SignedTransactionViewSchema = z.object({
    actions: z.array(ActionViewSchema),
    hash: CryptoHashSchema,
    nonce: z.number(),
    priority_fee: z.number(),
    public_key: PublicKeySchema,
    receiver_id: AccountIdSchema,
    signature: SignatureSchema,
    signer_id: AccountIdSchema
});
export const SlashedValidatorSchema = z.object({
    account_id: AccountIdSchema,
    is_double_sign: z.boolean()
});
export const StakeActionSchema = z.object({
    public_key: PublicKeySchema,
    stake: z.string()
});
export const StateChangeCauseViewSchema = z.union([z.object({
    type: z.literal("not_writable_to_disk")
}), z.object({
    type: z.literal("initial_state")
}), z.object({
    tx_hash: CryptoHashSchema,
    type: z.literal("transaction_processing")
}), z.object({
    receipt_hash: CryptoHashSchema,
    type: z.literal("action_receipt_processing_started")
}), z.object({
    receipt_hash: CryptoHashSchema,
    type: z.literal("action_receipt_gas_reward")
}), z.object({
    receipt_hash: CryptoHashSchema,
    type: z.literal("receipt_processing")
}), z.object({
    receipt_hash: CryptoHashSchema,
    type: z.literal("postponed_receipt")
}), z.object({
    type: z.literal("updated_delayed_receipts")
}), z.object({
    type: z.literal("validator_accounts_update")
}), z.object({
    type: z.literal("migration")
}), z.object({
    type: z.literal("bandwidth_scheduler_state_update")
})]);
export const StateChangeKindViewSchema = z.union([z.object({
    account_id: AccountIdSchema,
    type: z.literal("account_touched")
}), z.object({
    account_id: AccountIdSchema,
    type: z.literal("access_key_touched")
}), z.object({
    account_id: AccountIdSchema,
    type: z.literal("data_touched")
}), z.object({
    account_id: AccountIdSchema,
    type: z.literal("contract_code_touched")
})]);
export const StateChangeWithCauseViewSchema = z.object({
    cause: StateChangeCauseViewSchema
}).and(z.union([z.object({
    change: z.object({
        account_id: AccountIdSchema,
        amount: z.string(),
        code_hash: CryptoHashSchema,
        global_contract_account_id: z.union([AccountIdSchema, z.null()]).optional(),
        global_contract_hash: z.union([CryptoHashSchema, z.null()]).optional(),
        locked: z.string(),
        storage_paid_at: z.number(),
        storage_usage: z.number()
    }),
    type: z.literal("account_update")
}), z.object({
    change: z.object({
        account_id: AccountIdSchema
    }),
    type: z.literal("account_deletion")
}), z.object({
    change: z.object({
        access_key: AccessKeyViewSchema,
        account_id: AccountIdSchema,
        public_key: PublicKeySchema
    }),
    type: z.literal("access_key_update")
}), z.object({
    change: z.object({
        account_id: AccountIdSchema,
        public_key: PublicKeySchema
    }),
    type: z.literal("access_key_deletion")
}), z.object({
    change: z.object({
        account_id: AccountIdSchema,
        gas_key: GasKeyViewSchema,
        public_key: PublicKeySchema
    }),
    type: z.literal("gas_key_update")
}), z.object({
    change: z.object({
        account_id: AccountIdSchema,
        index: z.number(),
        nonce: z.number(),
        public_key: PublicKeySchema
    }),
    type: z.literal("gas_key_nonce_update")
}), z.object({
    change: z.object({
        account_id: AccountIdSchema,
        public_key: PublicKeySchema
    }),
    type: z.literal("gas_key_deletion")
}), z.object({
    change: z.object({
        account_id: AccountIdSchema,
        key_base64: z.string(),
        value_base64: z.string()
    }),
    type: z.literal("data_update")
}), z.object({
    change: z.object({
        account_id: AccountIdSchema,
        key_base64: z.string()
    }),
    type: z.literal("data_deletion")
}), z.object({
    change: z.object({
        account_id: AccountIdSchema,
        code_base64: z.string()
    }),
    type: z.literal("contract_code_update")
}), z.object({
    change: z.object({
        account_id: AccountIdSchema
    }),
    type: z.literal("contract_code_deletion")
})]));
export const StateItemSchema = z.object({
    key: z.string(),
    value: z.string()
});
export const StateSyncConfigSchema = z.object({
    concurrency: z.lazy(() => SyncConcurrencySchema).optional(),
    dump: z.union([DumpConfigSchema, z.null()]).optional(),
    sync: z.lazy(() => SyncConfigSchema).optional()
});
export const StatusSyncInfoSchema = z.object({
    earliest_block_hash: z.union([CryptoHashSchema, z.null()]).optional(),
    earliest_block_height: z.union([z.number(), z.null()]).optional(),
    earliest_block_time: z.union([z.string(), z.null()]).optional(),
    epoch_id: z.union([EpochIdSchema, z.null()]).optional(),
    epoch_start_height: z.union([z.number(), z.null()]).optional(),
    latest_block_hash: CryptoHashSchema,
    latest_block_height: z.number(),
    latest_block_time: z.string(),
    latest_state_root: CryptoHashSchema,
    syncing: z.boolean()
});
export const StorageErrorSchema = z.union([z.literal("StorageInternalError"), z.object({
    MissingTrieValue: MissingTrieValueSchema
}), z.literal("UnexpectedTrieValue"), z.object({
    StorageInconsistentState: z.string()
}), z.object({
    FlatStorageBlockNotSupported: z.string()
}), z.object({
    MemTrieLoadingError: z.string()
})]);
export const StorageGetModeSchema = z.union([z.literal("FlatStorage"), z.literal("Trie")]);
export const StorageUsageConfigViewSchema = z.object({
    num_bytes_account: z.number(),
    num_extra_bytes_record: z.number()
});
export const SyncCheckpointSchema = z.union([z.literal("genesis"), z.literal("earliest_available")]);
export const SyncConcurrencySchema = z.object({
    apply: z.number(),
    apply_during_catchup: z.number(),
    peer_downloads: z.number(),
    per_shard: z.number()
});
export const SyncConfigSchema = z.union([z.literal("Peers"), z.object({
    ExternalStorage: ExternalStorageConfigSchema
})]);
export const Tier1ProxyViewSchema = z.object({
    addr: z.string(),
    peer_id: PublicKeySchema
});
export const TrackedShardsConfigSchema = z.union([z.literal("NoShards"), z.object({
    Shards: z.array(ShardUIdSchema)
}), z.literal("AllShards"), z.object({
    ShadowValidator: AccountIdSchema
}), z.object({
    Schedule: z.array(z.array(ShardIdSchema))
}), z.object({
    Accounts: z.array(AccountIdSchema)
})]);
export const TransferActionSchema = z.object({
    deposit: z.string()
});
export const TxExecutionErrorSchema = z.union([z.object({
    ActionError: ActionErrorSchema
}), z.object({
    InvalidTxError: InvalidTxErrorSchema
})]);
export const TxExecutionStatusSchema = z.union([z.literal("NONE"), z.literal("INCLUDED"), z.literal("EXECUTED_OPTIMISTIC"), z.literal("INCLUDED_FINAL"), z.literal("EXECUTED"), z.literal("FINAL")]);
export const UseGlobalContractActionSchema = z.object({
    contract_identifier: GlobalContractIdentifierSchema
});
export const ValidatorInfoSchema = z.object({
    account_id: AccountIdSchema
});
export const ValidatorKickoutReasonSchema = z.union([z.literal("_UnusedSlashed"), z.object({
    NotEnoughBlocks: z.object({
        expected: z.number(),
        produced: z.number()
    })
}), z.object({
    NotEnoughChunks: z.object({
        expected: z.number(),
        produced: z.number()
    })
}), z.literal("Unstaked"), z.object({
    NotEnoughStake: z.object({
        stake_u128: z.string(),
        threshold_u128: z.string()
    })
}), z.literal("DidNotGetASeat"), z.object({
    NotEnoughChunkEndorsements: z.object({
        expected: z.number(),
        produced: z.number()
    })
}), z.object({
    ProtocolVersionTooOld: z.object({
        network_version: z.number(),
        version: z.number()
    })
})]);
export const ValidatorKickoutViewSchema = z.object({
    account_id: AccountIdSchema,
    reason: ValidatorKickoutReasonSchema
});
export const ValidatorStakeViewSchema = z.object({
    validator_stake_struct_version: z.literal("V1")
}).and(z.lazy(() => ValidatorStakeViewV1Schema));
export const ValidatorStakeViewV1Schema = z.object({
    account_id: AccountIdSchema,
    public_key: PublicKeySchema,
    stake: z.string()
});
export const VersionSchema = z.object({
    build: z.string(),
    commit: z.string(),
    rustc_version: z.string(),
    version: z.string()
});
export const ViewStateResultSchema = z.object({
    proof: z.array(z.string()).optional(),
    values: z.array(StateItemSchema)
});
export const VMConfigViewSchema = z.object({
    discard_custom_sections: z.boolean(),
    eth_implicit_accounts: z.boolean(),
    ext_costs: ExtCostsConfigViewSchema,
    fix_contract_loading_cost: z.boolean(),
    global_contract_host_fns: z.boolean(),
    grow_mem_cost: z.number(),
    implicit_account_creation: z.boolean(),
    limit_config: LimitConfigSchema,
    reftypes_bulk_memory: z.boolean(),
    regular_op_cost: z.number(),
    saturating_float_to_int: z.boolean(),
    storage_get_mode: StorageGetModeSchema,
    vm_kind: z.lazy(() => VMKindSchema)
});
export const VMKindSchema = z.union([z.literal("Wasmer0"), z.literal("Wasmtime"), z.literal("Wasmer2"), z.literal("NearVm"), z.literal("NearVm2")]);
export const WasmTrapSchema = z.union([z.literal("Unreachable"), z.literal("IncorrectCallIndirectSignature"), z.literal("MemoryOutOfBounds"), z.literal("CallIndirectOOB"), z.literal("IllegalArithmetic"), z.literal("MisalignedAtomicAccess"), z.literal("IndirectCallToNull"), z.literal("StackOverflow"), z.literal("GenericTrap")]);
export const WitnessConfigViewSchema = z.object({
    combined_transactions_size_limit: z.number(),
    main_storage_proof_size_soft_limit: z.number(),
    new_transactions_validation_state_size_soft_limit: z.number()
});
