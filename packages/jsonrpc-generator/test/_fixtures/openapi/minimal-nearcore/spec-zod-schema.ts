/**
 * THIS FILE IS GENERATED - DO NOT MODIFY DIRECTLY
 * Generated by @near-jsonrpc/jsonrpc-generator
 * 
 * @generated
 */
import { z } from "zod/v4";

export const AccountIdZodSchema = z.string();
export const BandwidthRequestZodSchema = z.object({
    requestedValuesBitmap: z.lazy(() => BandwidthRequestBitmapZodSchema),
    toShard: z.number()
});
export const BandwidthRequestBitmapZodSchema = z.object({
    data: z.array(z.number())
});
export const BandwidthRequestsZodSchema = z.object({
    V1: z.lazy(() => BandwidthRequestsV1ZodSchema)
});
export const BandwidthRequestsV1ZodSchema = z.object({
    requests: z.array(BandwidthRequestZodSchema)
});
export const BlockHeaderViewZodSchema = z.object({
    approvals: z.array(z.union([z.lazy(() => SignatureZodSchema), z.null()])),
    blockBodyHash: z.union([z.lazy(() => CryptoHashZodSchema), z.null()]).optional(),
    blockMerkleRoot: z.lazy(() => CryptoHashZodSchema),
    blockOrdinal: z.union([z.number(), z.null()]).optional(),
    challengesResult: z.array(z.lazy(() => SlashedValidatorZodSchema)),
    challengesRoot: z.lazy(() => CryptoHashZodSchema),
    chunkEndorsements: z.union([z.array(z.array(z.number())), z.null()]).optional(),
    chunkHeadersRoot: z.lazy(() => CryptoHashZodSchema),
    chunkMask: z.array(z.boolean()),
    chunkReceiptsRoot: z.lazy(() => CryptoHashZodSchema),
    chunkTxRoot: z.lazy(() => CryptoHashZodSchema),
    chunksIncluded: z.number(),
    epochId: z.lazy(() => CryptoHashZodSchema),
    epochSyncDataHash: z.union([z.lazy(() => CryptoHashZodSchema), z.null()]).optional(),
    gasPrice: z.string(),
    hash: z.lazy(() => CryptoHashZodSchema),
    height: z.number(),
    lastDsFinalBlock: z.lazy(() => CryptoHashZodSchema),
    lastFinalBlock: z.lazy(() => CryptoHashZodSchema),
    latestProtocolVersion: z.number(),
    nextBpHash: z.lazy(() => CryptoHashZodSchema),
    nextEpochId: z.lazy(() => CryptoHashZodSchema),
    outcomeRoot: z.lazy(() => CryptoHashZodSchema),
    prevHash: z.lazy(() => CryptoHashZodSchema),
    prevHeight: z.union([z.number(), z.null()]).optional(),
    prevStateRoot: z.lazy(() => CryptoHashZodSchema),
    randomValue: z.lazy(() => CryptoHashZodSchema),
    rentPaid: z.string(),
    signature: z.lazy(() => SignatureZodSchema),
    timestamp: z.number(),
    timestampNanosec: z.string(),
    totalSupply: z.string(),
    validatorProposals: z.array(z.lazy(() => ValidatorStakeViewZodSchema)),
    validatorReward: z.string()
});
export const BlockIdZodSchema = z.union([z.number(), z.lazy(() => CryptoHashZodSchema)]);
export const ChunkHeaderViewZodSchema = z.object({
    balanceBurnt: z.string(),
    bandwidthRequests: z.union([BandwidthRequestsZodSchema, z.null()]).optional(),
    chunkHash: z.lazy(() => CryptoHashZodSchema),
    congestionInfo: z.union([z.lazy(() => CongestionInfoViewZodSchema), z.null()]).optional(),
    encodedLength: z.number(),
    encodedMerkleRoot: z.lazy(() => CryptoHashZodSchema),
    gasLimit: z.number(),
    gasUsed: z.number(),
    heightCreated: z.number(),
    heightIncluded: z.number(),
    outcomeRoot: z.lazy(() => CryptoHashZodSchema),
    outgoingReceiptsRoot: z.lazy(() => CryptoHashZodSchema),
    prevBlockHash: z.lazy(() => CryptoHashZodSchema),
    prevStateRoot: z.lazy(() => CryptoHashZodSchema),
    rentPaid: z.string(),
    shardId: z.lazy(() => ShardIdZodSchema),
    signature: z.lazy(() => SignatureZodSchema),
    txRoot: z.lazy(() => CryptoHashZodSchema),
    validatorProposals: z.array(z.lazy(() => ValidatorStakeViewZodSchema)),
    validatorReward: z.string()
});
export const CongestionInfoViewZodSchema = z.object({
    allowedShard: z.number(),
    bufferedReceiptsGas: z.string(),
    delayedReceiptsGas: z.string(),
    receiptBytes: z.number()
});
export const CryptoHashZodSchema = z.string();
export const FinalityZodSchema = z.union([z.literal("optimistic"), z.literal("near-final"), z.literal("final")]);
export const PublicKeyZodSchema = z.string();
export const Range_of_uint64ZodSchema = z.object({
    end: z.number(),
    start: z.number()
});
export const RpcBlockRequestZodSchema = z.union([z.object({
    blockId: BlockIdZodSchema
}), z.object({
    finality: FinalityZodSchema
}), z.object({
    syncCheckpoint: z.lazy(() => SyncCheckpointZodSchema)
})]);
export const RpcBlockResponseZodSchema = z.object({
    author: AccountIdZodSchema,
    chunks: z.array(ChunkHeaderViewZodSchema),
    header: BlockHeaderViewZodSchema
});
export const RpcErrorZodSchema = z.object({
    cause: z.unknown().optional(),
    code: z.number(),
    data: z.unknown().optional(),
    message: z.string(),
    name: z.unknown().optional()
}).and(z.union([z.object({
    cause: z.lazy(() => RpcRequestValidationErrorKindZodSchema),
    name: z.literal("REQUEST_VALIDATION_ERROR")
}), z.object({
    cause: z.unknown(),
    name: z.literal("HANDLER_ERROR")
}), z.object({
    cause: z.unknown(),
    name: z.literal("INTERNAL_ERROR")
})]));
export const RpcHealthRequestZodSchema = z.null();
export const RpcHealthResponseZodSchema = z.null();
export const RpcMaintenanceWindowsRequestZodSchema = z.object({
    accountId: AccountIdZodSchema
});
export const RpcRequestValidationErrorKindZodSchema = z.union([z.object({
    info: z.object({
        methodName: z.string()
    }),
    name: z.literal("METHOD_NOT_FOUND")
}), z.object({
    info: z.object({
        errorMessage: z.string()
    }),
    name: z.literal("PARSE_ERROR")
})]);
export const RpcValidatorsOrderedRequestZodSchema = z.object({
    blockId: z.union([BlockIdZodSchema, z.null()]).optional()
});
export const ShardIdZodSchema = z.number();
export const SignatureZodSchema = z.string();
export const SlashedValidatorZodSchema = z.object({
    accountId: AccountIdZodSchema,
    isDoubleSign: z.boolean()
});
export const SyncCheckpointZodSchema = z.union([z.literal("genesis"), z.literal("earliest_available")]);
export const ValidatorStakeViewZodSchema = z.object({
    validatorStakeStructVersion: z.literal("V1")
}).and(z.lazy(() => ValidatorStakeViewV1ZodSchema));
export const ValidatorStakeViewV1ZodSchema = z.object({
    accountId: AccountIdZodSchema,
    publicKey: PublicKeyZodSchema,
    stake: z.string()
});
export const JsonRpcResponseForArrayOfRangeOfUint64AndRpcErrorResponseZodSchema = z.array(Range_of_uint64ZodSchema);
export const JsonRpcResponseForArrayOfValidatorStakeViewAndRpcErrorResponseZodSchema = z.array(ValidatorStakeViewZodSchema);
export const JsonRpcResponseForNullableRpcHealthResponseAndRpcErrorResponseZodSchema = z.union([RpcHealthResponseZodSchema, z.null()]);
