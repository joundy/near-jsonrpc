import { extendSchemaWithDiscriminators } from "../../src/builder/extend-schema-with-discriminators";
import { SchemaDiscriminator } from "../../src/types";

describe("Extend Schema With Discriminators", () => {
  it("should extend schema with discriminators with type literal", () => {
    const fixture = {
      schemaTs: `/**
* THIS FILE IS GENERATED - DO NOT MODIFY DIRECTLY
* Generated by @near-jsonrpc/jsonrpc-generator
*
* @generated
*/
export type TypeA = {
  type_a_a: string,
  type_a_b: number
}
export type TypeB = {
  type_b_a: string,
  type_b_b: number
}
export type WantToDiscriminate = {
  a: string,
  b: number
} & (TypeA | TypeB);
`,
      expect: `/**
* THIS FILE IS GENERATED - DO NOT MODIFY DIRECTLY
* Generated by @near-jsonrpc/jsonrpc-generator
*
* @generated
*/
export type TypeA = {
    type_a_a: string,
    type_a_b: number
}
export type TypeB = {
    type_b_a: string,
    type_b_b: number
}
export type WantToDiscriminate = {
    a: string,
    b: number
} & (TypeA | TypeB);

export function DiscriminateWantToDiscriminate(obj: WantToDiscriminate): {
    TypeA?: { a: string, b: number }
    & TypeA;
    TypeB?: { a: string, b: number }
    & TypeB;
} {
    let TypeA: ReturnType<typeof DiscriminateWantToDiscriminate>['TypeA'] = undefined
    let TypeB: ReturnType<typeof DiscriminateWantToDiscriminate>['TypeB'] = undefined
    if ("type_a_a" in obj && "type_a_b" in obj) {
        TypeA = obj;
    }
    if ("type_b_a" in obj && "type_b_b" in obj) {
        TypeB = obj;
    }
    return {
        TypeA,
        TypeB
    };
}
`,
    };
    const schemaDiscriminators: SchemaDiscriminator[] = [
      {
        schema: "WantToDiscriminate",
        typeLiteral: `{ a: string, b: number }`,
        refDiscriminators: [
          {
            referenceSchema: "TypeA",
            properties: ["type_a_a", "type_a_b"],
          },
          {
            referenceSchema: "TypeB",
            properties: ["type_b_a", "type_b_b"],
          },
        ],
      },
    ];
    const result = extendSchemaWithDiscriminators(
      fixture.schemaTs,
      schemaDiscriminators
    );
    expect(result).toBe(fixture.expect);
  });

  it("should extend schema with discriminators without type literal", () => {
    const fixture = {
      schemaTs: `/**
* THIS FILE IS GENERATED - DO NOT MODIFY DIRECTLY
* Generated by @near-jsonrpc/jsonrpc-generator
*
* @generated
*/
export type TypeA = {
  type_a_a: string,
  type_a_b: number
}
export type TypeB = {
  type_b_a: string,
  type_b_b: number
}
export type WantToDiscriminate = TypeA | TypeB;
`,
      expect: `/**
* THIS FILE IS GENERATED - DO NOT MODIFY DIRECTLY
* Generated by @near-jsonrpc/jsonrpc-generator
*
* @generated
*/
export type TypeA = {
    type_a_a: string,
    type_a_b: number
}
export type TypeB = {
    type_b_a: string,
    type_b_b: number
}
export type WantToDiscriminate = TypeA | TypeB;

export function DiscriminateWantToDiscriminate(obj: WantToDiscriminate): {
    TypeA?: TypeA;
    TypeB?: TypeB;
} {
    let TypeA: ReturnType<typeof DiscriminateWantToDiscriminate>['TypeA'] = undefined
    let TypeB: ReturnType<typeof DiscriminateWantToDiscriminate>['TypeB'] = undefined
    if ("type_a_a" in obj && "type_a_b" in obj) {
        TypeA = obj;
    }
    if ("type_b_a" in obj && "type_b_b" in obj) {
        TypeB = obj;
    }
    return {
        TypeA,
        TypeB
    };
}
`,
    };
    const schemaDiscriminators: SchemaDiscriminator[] = [
      {
        schema: "WantToDiscriminate",
        refDiscriminators: [
          {
            referenceSchema: "TypeA",
            properties: ["type_a_a", "type_a_b"],
          },
          {
            referenceSchema: "TypeB",
            properties: ["type_b_a", "type_b_b"],
          },
        ],
      },
    ];
    const result = extendSchemaWithDiscriminators(
      fixture.schemaTs,
      schemaDiscriminators
    );
    expect(result).toBe(fixture.expect);
  });
});
